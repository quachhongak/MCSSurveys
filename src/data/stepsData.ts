export const stepsData = [
  {
    id: 1,
    title: "Step 1: Introduction to Assessment",
    description: "This step covers the fundamental concepts you need to understand before proceeding with the assessment.",
    resources: [
      {
        id: 1,
        title: "Official Documentation",
        url: "https://reactjs.org/docs/getting-started.html",
        type: "external",
      },
      {
        id: 2,
        title: "Video Tutorial",
        url: "https://www.youtube.com/watch?v=Ke90Tje7VS0",
        type: "external",
      },
      {
        id: 3,
        title: "Interactive Guide",
        url: "https://react.dev/learn",
        type: "external",
      },
    ],
    questions: [
      {
        id: 1,
        type: "multiple-choice",
        question: "What is the primary purpose of this assessment?",
        options: [
          "To test basic knowledge",
          "To evaluate practical skills",
          "To measure comprehension",
          "All of the above",
        ],
        correctAnswer: "All of the above",
        explanation: "This assessment evaluates multiple aspects of understanding including knowledge, skills, and comprehension.",
      },
      {
        id: 2,
        type: "true-false",
        question: "This assessment requires 100% accuracy to pass.",
        correctAnswer: true,
        explanation: "Yes, you must answer all questions correctly to successfully complete each step.",
      },
      {
        id: 3,
        type: "fill-in-blank",
        question: "Complete the sentence: The assessment consists of _____ total steps.",
        correctAnswer: "12",
        explanation: "There are exactly 12 steps in this assessment process.",
      },
      {
        id: 4,
        type: "multiple-choice",
        question: "Which approach is used for state management in this application?",
        options: ["Redux", "Context API", "MobX", "Zustand"],
        correctAnswer: "Context API",
        explanation: "This application uses React's Context API with useReducer for state management.",
      },
      {
        id: 5,
        type: "true-false",
        question: "The application uses external UI libraries for styling.",
        correctAnswer: false,
        explanation: "The application uses plain CSS with BEM methodology, no external UI libraries.",
      },
    ],
  },
  {
    id: 2,
    title: "Step 2: React Fundamentals",
    description: "Learn the core concepts of React including components, props, and state management.",
    resources: [
      {
        id: 1,
        title: "React Components Guide",
        url: "https://react.dev/learn/your-first-component",
        type: "external",
      },
      {
        id: 2,
        title: "Props vs State",
        url: "https://react.dev/learn/passing-props-to-a-component",
        type: "external",
      },
      {
        id: 3,
        title: "State Management",
        url: "https://react.dev/learn/state-a-components-memory",
        type: "external",
      },
    ],
    questions: [
      {
        id: 1,
        type: "multiple-choice",
        question: "What is a React component?",
        options: [
          "A JavaScript function that returns HTML",
          "A reusable piece of UI",
          "A building block of React applications",
          "All of the above",
        ],
        correctAnswer: "All of the above",
        explanation: "React components are JavaScript functions that return JSX and serve as reusable UI building blocks.",
      },
      {
        id: 2,
        type: "true-false",
        question: "Props can be modified within a component.",
        correctAnswer: false,
        explanation: "Props are read-only and cannot be modified within a component. They are passed down from parent components.",
      },
      {
        id: 3,
        type: "fill-in-blank",
        question: "The _____ hook is used to add state to functional components.",
        correctAnswer: "useState",
        explanation: "The useState hook allows functional components to have local state.",
      },
      {
        id: 4,
        type: "multiple-choice",
        question: "What triggers a component re-render?",
        options: ["State change", "Props change", "Parent re-render", "All of the above"],
        correctAnswer: "All of the above",
        explanation: "Components re-render when state changes, props change, or when their parent component re-renders.",
      },
      {
        id: 5,
        type: "true-false",
        question: "JSX is required to write React components.",
        correctAnswer: false,
        explanation: "JSX is not required but is commonly used. You can write React components using React.createElement().",
      },
    ],
  },
  {
    id: 3,
    title: "Step 3: Component Lifecycle",
    description: "Understanding React component lifecycle methods and hooks for managing component behavior.",
    resources: [
      {
        id: 1,
        title: "useEffect Hook Guide",
        url: "https://react.dev/learn/synchronizing-with-effects",
        type: "external",
      },
      {
        id: 2,
        title: "Lifecycle Methods",
        url: "https://react.dev/reference/react/Component#lifecycle",
        type: "external",
      },
      {
        id: 3,
        title: "Cleanup Functions",
        url: "https://react.dev/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development",
        type: "external",
      },
    ],
    questions: [
      {
        id: 1,
        type: "multiple-choice",
        question: "Which hook replaces componentDidMount in functional components?",
        options: ["useState", "useEffect", "useContext", "useReducer"],
        correctAnswer: "useEffect",
        explanation: "useEffect with an empty dependency array mimics componentDidMount behavior.",
      },
      {
        id: 2,
        type: "true-false",
        question: "useEffect runs after every render by default.",
        correctAnswer: true,
        explanation: "useEffect runs after every render unless you provide a dependency array to control when it runs.",
      },
      {
        id: 3,
        type: "fill-in-blank",
        question: "To prevent memory leaks, you should return a _____ function from useEffect.",
        correctAnswer: "cleanup",
        explanation: "Cleanup functions are returned from useEffect to clean up subscriptions, timers, etc.",
      },
      {
        id: 4,
        type: "multiple-choice",
        question: "What happens when you pass an empty array as the second argument to useEffect?",
        options: [
          "Effect runs on every render",
          "Effect runs only once after mount",
          "Effect never runs",
          "Effect runs on unmount only",
        ],
        correctAnswer: "Effect runs only once after mount",
        explanation: "An empty dependency array makes useEffect run only once after the component mounts.",
      },
      {
        id: 5,
        type: "true-false",
        question: "You can have multiple useEffect hooks in a single component.",
        correctAnswer: true,
        explanation: "You can use multiple useEffect hooks to separate concerns and organize side effects.",
      },
    ],
  },
  {
    id: 4,
    title: "Step 4: Event Handling",
    description: "Learn how to handle user interactions and events in React applications.",
    resources: [
      {
        id: 1,
        title: "Handling Events",
        url: "https://react.dev/learn/responding-to-events",
        type: "external",
      },
      {
        id: 2,
        title: "SyntheticEvent",
        url: "https://react.dev/reference/react-dom/components/common#react-event-object",
        type: "external",
      },
      {
        id: 3,
        title: "Event Delegation",
        url: "https://react.dev/learn/responding-to-events#event-propagation",
        type: "external",
      },
    ],
    questions: [
      {
        id: 1,
        type: "multiple-choice",
        question: "How do you prevent the default behavior of an event in React?",
        options: [
          "event.preventDefault()",
          "return false",
          "event.stopPropagation()",
          "event.cancel()",
        ],
        correctAnswer: "event.preventDefault()",
        explanation: "event.preventDefault() prevents the default behavior of an event in React.",
      },
      {
        id: 2,
        type: "true-false",
        question: "React events are native DOM events.",
        correctAnswer: false,
        explanation: "React uses SyntheticEvents, which are wrappers around native events for cross-browser compatibility.",
      },
      {
        id: 3,
        type: "fill-in-blank",
        question: "To pass additional parameters to an event handler, you can use an _____ function.",
        correctAnswer: "arrow",
        explanation: "Arrow functions allow you to pass additional parameters to event handlers.",
      },
      {
        id: 4,
        type: "multiple-choice",
        question: "What is event bubbling?",
        options: [
          "Events firing in random order",
          "Events propagating from child to parent",
          "Events being cancelled",
          "Events firing multiple times",
        ],
        correctAnswer: "Events propagating from child to parent",
        explanation: "Event bubbling is when events propagate from the target element up to its parents.",
      },
      {
        id: 5,
        type: "true-false",
        question: "You should bind event handlers in the render method.",
        correctAnswer: false,
        explanation: "Binding in render creates new functions on every render. Use arrow functions or bind in constructor.",
      },
    ],
  },
  {
    id: 5,
    title: "Step 5: Forms and Controlled Components",
    description: "Master form handling, controlled components, and form validation in React.",
    resources: [
      {
        id: 1,
        title: "Controlled Components",
        url: "https://react.dev/reference/react-dom/components/input#controlling-an-input-with-a-state-variable",
        type: "external",
      },
      {
        id: 2,
        title: "Form Handling",
        url: "https://react.dev/learn/reacting-to-input-with-state",
        type: "external",
      },
      {
        id: 3,
        title: "Form Validation",
        url: "https://react.dev/learn/reacting-to-input-with-state#choosing-the-state-structure",
        type: "external",
      },
    ],
    questions: [
      {
        id: 1,
        type: "multiple-choice",
        question: "What makes a component 'controlled'?",
        options: [
          "It has state",
          "Its value is controlled by React state",
          "It handles events",
          "It has props",
        ],
        correctAnswer: "Its value is controlled by React state",
        explanation: "A controlled component's value is controlled by React state, not the DOM.",
      },
      {
        id: 2,
        type: "true-false",
        question: "Uncontrolled components store their state in the DOM.",
        correctAnswer: true,
        explanation: "Uncontrolled components let the DOM handle the form data instead of React state.",
      },
      {
        id: 3,
        type: "fill-in-blank",
        question: "The _____ attribute is used to get the current value of an uncontrolled component.",
        correctAnswer: "ref",
        explanation: "Refs are used to access DOM elements directly, including getting values from uncontrolled components.",
      },
      {
        id: 4,
        type: "multiple-choice",
        question: "Which is the recommended approach for form handling in React?",
        options: [
          "Uncontrolled components",
          "Controlled components",
          "Both are equally good",
          "Neither, use external libraries",
        ],
        correctAnswer: "Controlled components",
        explanation: "Controlled components are recommended as they give React full control over form data.",
      },
      {
        id: 5,
        type: "true-false",
        question: "You need to prevent default form submission in React forms.",
        correctAnswer: true,
        explanation: "You typically need to prevent default form submission to handle it with JavaScript instead.",
      },
    ],
  },
  {
    id: 6,
    title: "Step 6: Context API and State Management",
    description: "Learn advanced state management using Context API and useReducer hook.",
    resources: [
      {
        id: 1,
        title: "Context API Guide",
        url: "https://react.dev/learn/passing-data-deeply-with-context",
        type: "external",
      },
      {
        id: 2,
        title: "useReducer Hook",
        url: "https://react.dev/reference/react/useReducer",
        type: "external",
      },
      {
        id: 3,
        title: "State Management Patterns",
        url: "https://react.dev/learn/extracting-state-logic-into-a-reducer",
        type: "external",
      },
    ],
    questions: [
      {
        id: 1,
        type: "multiple-choice",
        question: "What problem does Context API solve?",
        options: [
          "Component re-rendering",
          "Prop drilling",
          "State mutations",
          "Memory leaks",
        ],
        correctAnswer: "Prop drilling",
        explanation: "Context API helps avoid prop drilling by providing a way to share data across components without passing props through every level.",
      },
      {
        id: 2,
        type: "true-false",
        question: "useReducer is always better than useState for state management.",
        correctAnswer: false,
        explanation: "useReducer is better for complex state logic, but useState is simpler for basic state needs.",
      },
      {
        id: 3,
        type: "fill-in-blank",
        question: "Context API consists of _____ and Consumer components.",
        correctAnswer: "Provider",
        explanation: "Context API uses Provider to supply values and Consumer (or useContext hook) to consume them.",
      },
      {
        id: 4,
        type: "multiple-choice",
        question: "When should you use useReducer instead of useState?",
        options: [
          "For simple boolean state",
          "For complex state logic with multiple sub-values",
          "For string values only",
          "Never, useState is always better",
        ],
        correctAnswer: "For complex state logic with multiple sub-values",
        explanation: "useReducer is ideal for complex state logic involving multiple sub-values or when next state depends on previous state.",
      },
      {
        id: 5,
        type: "true-false",
        question: "Context value changes cause all consuming components to re-render.",
        correctAnswer: true,
        explanation: "When context value changes, all components consuming that context will re-render.",
      },
    ],
  },
  {
    id: 7,
    title: "Step 7: Performance Optimization",
    description: "Optimize React applications using memoization, lazy loading, and other techniques.",
    resources: [
      {
        id: 1,
        title: "React.memo",
        url: "https://react.dev/reference/react/memo",
        type: "external",
      },
      {
        id: 2,
        title: "useMemo and useCallback",
        url: "https://react.dev/reference/react/useMemo",
        type: "external",
      },
      {
        id: 3,
        title: "Code Splitting",
        url: "https://react.dev/reference/react/lazy",
        type: "external",
      },
    ],
    questions: [
      {
        id: 1,
        type: "multiple-choice",
        question: "What does React.memo do?",
        options: [
          "Memoizes function results",
          "Prevents unnecessary re-renders",
          "Caches API responses",
          "Optimizes bundle size",
        ],
        correctAnswer: "Prevents unnecessary re-renders",
        explanation: "React.memo is a higher-order component that prevents re-renders when props haven't changed.",
      },
      {
        id: 2,
        type: "true-false",
        question: "useMemo should be used for every calculation in React.",
        correctAnswer: false,
        explanation: "useMemo should only be used for expensive calculations. Overusing it can hurt performance.",
      },
      {
        id: 3,
        type: "fill-in-blank",
        question: "The _____ hook is used to memoize callback functions.",
        correctAnswer: "useCallback",
        explanation: "useCallback memoizes callback functions to prevent unnecessary re-renders of child components.",
      },
      {
        id: 4,
        type: "multiple-choice",
        question: "What is code splitting?",
        options: [
          "Dividing code into multiple files",
          "Loading code only when needed",
          "Separating CSS from JS",
          "Using multiple React apps",
        ],
        correctAnswer: "Loading code only when needed",
        explanation: "Code splitting allows you to load parts of your application only when they're needed, improving initial load time.",
      },
      {
        id: 5,
        type: "true-false",
        question: "React.lazy can be used with regular function components.",
        correctAnswer: false,
        explanation: "React.lazy only works with dynamic imports and components that are default exports.",
      },
    ],
  },
  {
    id: 8,
    title: "Step 8: Testing React Components",
    description: "Learn testing strategies and tools for React applications including unit and integration tests.",
    resources: [
      {
        id: 1,
        title: "Testing Library",
        url: "https://testing-library.com/docs/react-testing-library/intro/",
        type: "external",
      },
      {
        id: 2,
        title: "Jest Testing Framework",
        url: "https://jestjs.io/docs/tutorial-react",
        type: "external",
      },
      {
        id: 3,
        title: "Testing Best Practices",
        url: "https://kentcdodds.com/blog/common-mistakes-with-react-testing-library",
        type: "external",
      },
    ],
    questions: [
      {
        id: 1,
        type: "multiple-choice",
        question: "What is the recommended way to select elements in React Testing Library?",
        options: [
          "By className",
          "By id",
          "By accessible roles and labels",
          "By tag name",
        ],
        correctAnswer: "By accessible roles and labels",
        explanation: "React Testing Library encourages testing in a way that resembles how users interact with your app.",
      },
      {
        id: 2,
        type: "true-false",
        question: "You should test implementation details in React components.",
        correctAnswer: false,
        explanation: "You should test behavior and outcomes, not implementation details, to make tests more maintainable.",
      },
      {
        id: 3,
        type: "fill-in-blank",
        question: "The _____ function is used to render components in tests.",
        correctAnswer: "render",
        explanation: "The render function from React Testing Library is used to render components for testing.",
      },
      {
        id: 4,
        type: "multiple-choice",
        question: "What is a snapshot test?",
        options: [
          "Testing component performance",
          "Testing component output against saved version",
          "Testing component state",
          "Testing component props",
        ],
        correctAnswer: "Testing component output against saved version",
        explanation: "Snapshot tests compare component output to a previously saved version to detect unexpected changes.",
      },
      {
        id: 5,
        type: "true-false",
        question: "Integration tests are more valuable than unit tests for React components.",
        correctAnswer: true,
        explanation: "Integration tests often provide more confidence as they test how components work together, closer to real usage.",
      },
    ],
  },
  {
    id: 9,
    title: "Step 9: Routing and Navigation",
    description: "Implement client-side routing and navigation in React applications using React Router.",
    resources: [
      {
        id: 1,
        title: "React Router Guide",
        url: "https://reactrouter.com/en/main/start/tutorial",
        type: "external",
      },
      {
        id: 2,
        title: "Navigation Patterns",
        url: "https://reactrouter.com/en/main/components/nav-link",
        type: "external",
      },
      {
        id: 3,
        title: "Route Protection",
        url: "https://reactrouter.com/en/main/start/concepts#authentication",
        type: "external",
      },
    ],
    questions: [
      {
        id: 1,
        type: "multiple-choice",
        question: "What is the purpose of React Router?",
        options: [
          "State management",
          "Client-side routing",
          "API calls",
          "Component styling",
        ],
        correctAnswer: "Client-side routing",
        explanation: "React Router enables client-side routing, allowing navigation between different views without page refreshes.",
      },
      {
        id: 2,
        type: "true-false",
        question: "BrowserRouter uses the HTML5 history API.",
        correctAnswer: true,
        explanation: "BrowserRouter uses the HTML5 history API to keep UI in sync with the URL.",
      },
      {
        id: 3,
        type: "fill-in-blank",
        question: "The _____ component is used to define route paths and their corresponding components.",
        correctAnswer: "Route",
        explanation: "Route components define the mapping between URL paths and React components.",
      },
      {
        id: 4,
        type: "multiple-choice",
        question: "How do you programmatically navigate in React Router v6?",
        options: [
          "history.push()",
          "useNavigate() hook",
          "window.location",
          "redirect()",
        ],
        correctAnswer: "useNavigate() hook",
        explanation: "In React Router v6, the useNavigate hook is used for programmatic navigation.",
      },
      {
        id: 5,
        type: "true-false",
        question: "Route parameters are accessed using the useParams hook.",
        correctAnswer: true,
        explanation: "The useParams hook provides access to route parameters defined in the URL path.",
      },
    ],
  },
  {
    id: 10,
    title: "Step 10: API Integration",
    description: "Learn how to integrate APIs, handle asynchronous operations, and manage loading states.",
    resources: [
      {
        id: 1,
        title: "Fetch API Guide",
        url: "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch",
        type: "external",
      },
      {
        id: 2,
        title: "Async/Await in React",
        url: "https://react.dev/learn/synchronizing-with-effects#fetching-data",
        type: "external",
      },
      {
        id: 3,
        title: "Error Handling",
        url: "https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary",
        type: "external",
      },
    ],
    questions: [
      {
        id: 1,
        type: "multiple-choice",
        question: "Where should you typically make API calls in React?",
        options: [
          "In the render method",
          "In useEffect hook",
          "In the constructor",
          "In event handlers only",
        ],
        correctAnswer: "In useEffect hook",
        explanation: "API calls should typically be made in useEffect to avoid side effects during rendering.",
      },
      {
        id: 2,
        type: "true-false",
        question: "You should always show loading states when making API calls.",
        correctAnswer: true,
        explanation: "Loading states improve user experience by indicating that an operation is in progress.",
      },
      {
        id: 3,
        type: "fill-in-blank",
        question: "The _____ method is commonly used to make HTTP requests in modern JavaScript.",
        correctAnswer: "fetch",
        explanation: "The fetch API is the modern standard for making HTTP requests in JavaScript.",
      },
      {
        id: 4,
        type: "multiple-choice",
        question: "How should you handle API errors in React?",
        options: [
          "Ignore them",
          "Log to console only",
          "Show user-friendly error messages",
          "Crash the application",
        ],
        correctAnswer: "Show user-friendly error messages",
        explanation: "API errors should be handled gracefully with user-friendly error messages and fallback UI.",
      },
      {
        id: 5,
        type: "true-false",
        question: "You should cancel API requests when components unmount.",
        correctAnswer: true,
        explanation: "Canceling API requests prevents memory leaks and state updates on unmounted components.",
      },
    ],
  },
  {
    id: 11,
    title: "Step 11: Accessibility and Best Practices",
    description: "Implement accessibility features and follow React best practices for inclusive applications.",
    resources: [
      {
        id: 1,
        title: "React Accessibility",
        url: "https://react.dev/learn/accessibility",
        type: "external",
      },
      {
        id: 2,
        title: "ARIA Guidelines",
        url: "https://www.w3.org/WAI/ARIA/apg/",
        type: "external",
      },
      {
        id: 3,
        title: "Web Accessibility Checklist",
        url: "https://webaim.org/standards/wcag/checklist",
        type: "external",
      },
    ],
    questions: [
      {
        id: 1,
        type: "multiple-choice",
        question: "What does ARIA stand for?",
        options: [
          "Accessible Rich Internet Applications",
          "Advanced React Interface Architecture",
          "Automated Responsive Interface Adapter",
          "Application Resource Integration API",
        ],
        correctAnswer: "Accessible Rich Internet Applications",
        explanation: "ARIA (Accessible Rich Internet Applications) provides semantic information for assistive technologies.",
      },
      {
        id: 2,
        type: "true-false",
        question: "All interactive elements should be keyboard accessible.",
        correctAnswer: true,
        explanation: "Keyboard accessibility is essential for users who cannot use a mouse or touch interface.",
      },
      {
        id: 3,
        type: "fill-in-blank",
        question: "The _____ attribute provides accessible names for elements.",
        correctAnswer: "aria-label",
        explanation: "aria-label provides an accessible name when the visible text is not sufficient or available.",
      },
      {
        id: 4,
        type: "multiple-choice",
        question: "What is the minimum color contrast ratio for normal text?",
        options: ["2:1", "3:1", "4.5:1", "7:1"],
        correctAnswer: "4.5:1",
        explanation: "WCAG guidelines require a minimum contrast ratio of 4.5:1 for normal text to ensure readability.",
      },
      {
        id: 5,
        type: "true-false",
        question: "Screen readers can automatically understand the purpose of all UI elements.",
        correctAnswer: false,
        explanation: "Screen readers need semantic HTML and ARIA attributes to understand the purpose and state of UI elements.",
      },
    ],
  },
  {
    id: 12,
    title: "Step 12: Deployment and Production",
    description: "Learn how to build, optimize, and deploy React applications to production environments.",
    resources: [
      {
        id: 1,
        title: "Building for Production",
        url: "https://create-react-app.dev/docs/production-build/",
        type: "external",
      },
      {
        id: 2,
        title: "Deployment Options",
        url: "https://create-react-app.dev/docs/deployment/",
        type: "external",
      },
      {
        id: 3,
        title: "Performance Monitoring",
        url: "https://web.dev/vitals/",
        type: "external",
      },
    ],
    questions: [
      {
        id: 1,
        type: "multiple-choice",
        question: "What command builds a React app for production?",
        options: ["npm start", "npm build", "npm run build", "npm deploy"],
        correctAnswer: "npm run build",
        explanation: "npm run build creates an optimized production build of your React application.",
      },
      {
        id: 2,
        type: "true-false",
        question: "Production builds are larger than development builds.",
        correctAnswer: false,
        explanation: "Production builds are optimized and minified, making them smaller than development builds.",
      },
      {
        id: 3,
        type: "fill-in-blank",
        question: "The production build files are typically placed in the _____ folder.",
        correctAnswer: "build",
        explanation: "Create React App places production build files in the 'build' folder by default.",
      },
      {
        id: 4,
        type: "multiple-choice",
        question: "Which is NOT a common deployment platform for React apps?",
        options: ["Netlify", "Vercel", "GitHub Pages", "MySQL"],
        correctAnswer: "MySQL",
        explanation: "MySQL is a database system, not a deployment platform. The others are popular hosting services for React apps.",
      },
      {
        id: 5,
        type: "true-false",
        question: "You should monitor Core Web Vitals in production applications.",
        correctAnswer: true,
        explanation: "Core Web Vitals are important metrics for user experience and should be monitored in production.",
      },
    ],
  },
];